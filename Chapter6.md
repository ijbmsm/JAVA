# 클래스

## 객체 지향 프로그래밍
+ 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
  + 객체   : 자신의 속성(색깔, 나이, 동작, 모델명...등)을 가지고 있고 다른 것과 식별 가능한 것.
  + 필드   : 객체의 정보(상태)
  + 메소드 : 객체의 동작(기능)
``` java
class SmartPhone {
  /* 필드 */
  String name; // 이름
  String color; // 색상
  int price; // 가격
  
  /* 메소드 */
  void call(String phoneNum) {
    // 전화 걸기
  }
  void messege(String phoneNum) {
    // 메세지 보내기
  }
}
```

### 객체의 상호작용
+ 객체들은 각각 독립적으로 존재하며 객체들 사이의 상호작용 수단은 메소드이다.
  + 메소드 호출 : 객체가 다른 객체의 기능을 이용하는 것.
  + 매개값 : 메소드를 실행하기 위해 필요한 데이터. 
  + 리턴값 : 메소드가 실행하고 나서 호출한 곳으로 돌려주는 값.
```
int result = Calculator.add(10,20);
 리턴값 저장   객체      메소드
```

### 객체 간의 관계
+ 객체간의 관계에는 집합 관계, 사용 관계, 상속 관계가 있다.
  + 집합 관계 : 완성품과 부품의 관계
  + 사용 관계 : 객체가 다른 객체를 사용하는 관계
  + 상속 관계 : 상위객체를 기반으로 하위객체를 생성하는 관계
 
### 객체 지향 프로그래밍의 특징
+ 캡슐화 : 객체의 필드, 메소드를 하나로 묶어 구현 내용을 감추는 것.
  + 외부 객체는 객체가 노출해서 제공하는 필드와 메소드만 이용 가능.
  + 외부의 잘못된 사용(마음대로 변경)으로 인한 오남용을 막기 위함.

+ 상속 : 상위객체의 필드와 메소드를 하위 객체에게 물려줌
  + 하위 객체를 쉽게 빨리 설계할 수 있도록 도와준다.
  + 유지 보수가 편리하다.

+ 다형성 : 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질.
  + 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.
  + 객체는 부품화가 가능하다.

## 객체와 클래스
+ 메모리에서 사용하고 싶은 객체가 있다면 설계도로 해당 객체를 만들어야 한다. 자바에서는 설계도가 클래스이다. 
+ 클래스 : 객체를 생성하기 위한 설계도 혹은 틀. 객체들의 속성을 묶어 놓은 집합체
+ 객체 : 모든인스턴스를 대표하는 일반적 용어
+ 인스턴스 : 특정 클래스로부터 만들어진 객체(TV인스턴스, Car인스턴스)
+ 인스턴스화 : 클래스로부터 객체를 만드는 과정

+ 객체지향 프로그래밍 개발 단계
```
클래스 설계 -> 클래스를 가지고 객체 생성 -> 객체 프로그래밍
```

## 클래스 선언
+ 작성규칙

|번호|작성 규칙|예|
|:--|:------------|:-----|
|1|하나 이상의 문자로 이루어져야 한다.|Car, SportsCar|
|2|첫 번째 글자는 숫자가 올 수 없다.|2Car, 1999Sungmin|
|3|언더바, '$' 외의 특수 문자는 사용할 수 없다| $Car, @Car(X)|
|4|자바 키워드는 사용할 수 없다.|int, for|

+ 클래스 이름을 정했다면"클래스이름.java"로 소스 파일을 생성해야 한다. 
``` java
public class Car {

}

class Tire{
}
```
+ 하나의 자바 소스 파일에 작성된 클래스 중 하나의 클래스만 public으로 선언할 수 있다.
  + 소스파일 이름과 동일한 클래스에만 public으로 선언할 수 있다. 

## 객체 생성과 클래스 변수
+ new는 클래스로부터 객체를 생성시키는 연산자이다.
+ 생성자 : new 연산자를 통해 객체를 생성할 때 호출되는 멤버 변수(객체의 속성)을 초기화하는 역할
```
클래스 변수; 
변수 = new 클래스;

Car car; // Car 클래스의 객체를 참조하기 위한 참조변수(car)을 선언
car = new Car; // Car인스턴스를 생성한 후, 인스턴스의 주소를 car에 저장


클래스 변수 = new 클래스;
```
+ 위처럼 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다.
+ 객체의 사용
``` java
Car car = new Car;
car.speed = 100; //Car인스턴스의 멤버변수 speed의 값을 100으로 한다
car.speedUp(); //Car인스턴스의 메서드 speedUp()을 호출한다.
```

## 클래스의 구성 멤버
#### 필드
+ 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장한다.
+ 필드는 클래스에서 내부 멤버이기 때문에 멤버변수라고 불리고, 클래스 내 전역에서 사용하기 때문에 전역 변수라고 불린다.
+ 생성자와 메소드 밖에서 사용한다. 즉 클래스 안에서 독립적으로 선언되는 변수를 뜻한다.

+ 필드 선언
  + 필드는 클래스 블록 어디서든 존재할 수 있지만 생성자와 메소드 블록 내부에서는 선언될 수 없다.
  + 필드의 선언
``` java
String company = "현대자동차";
int speed = 300;
int age; // 선언만 하고 값을 넣지 않으면 초기값이 기본값으로 저장된다.
```
+ 필드의 사용
``` java
Car car = new Car;
car.speed = 100; //객체에 저장되어 있는 값(필드값)을 변경한다.
```
+ 필드를 사용한다는 것은 필드값을 읽고,변경하는 작업을 말한다.
+ 클래스 외부에서 사용할 경우 객체를 생성해야 한다.
  + 필드는 객체에 소속된 데이터이기 때문이다.
  + 필드의 사용은 변수와 비슷하지만 자신이 선언되지 않은 생성자, 메소드에서도 사용이 가능하다.

#### 생성자
+ 생성자는 객체 생성 시 초기화를 담당한다.
+ 메소드와 비슷하지만 메소드와는 다르게 리턴값이 없다.
+ new 연산자에 의해 생성자가 성공적으로 실행되면 heap영역에 객체가 생성되고 객체의 주소가 리턴된다.
+ 생성자가 실행되지 않고 에러가 발생한다면 객체는 생성되지 않는다.
+ 기본 생성자
  + 모든 클래스에는 생성자가 반드시 존재하고, 하나 이상 가질 수 있다..
  + 생성자 선언을 생략하면 컴파일러는 기본 생상자를 바이트 코드에 자동 추가시킨다.
``` java
ClassName() {} // 자동 추가된 생성자

public class Car{
  public Car() { } // 클래스가 public class로 선언되면 기보 생성자에서도 public이 붙는다.
}
```
  + 다음과 같이 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성시키면 컴파일러는 기본 생성자를 추가하지 않는다.
``` java
Car myCar = new Car();
```

+ 생성자 선언
``` java
클래스(매개변수 선언, ...){
  // 객체의 초기화 코드;
} 
``` 
  + 생성자는 리턴 타입이 없고, 클래스 이름과 동일하다. 
  + 매개 변수 선언은 생략할 수 있고, 여러 개를 선언할 수 있다.
``` java
public class Car {
  Car(String model, String color, int maxSpeed) {...} // 생성자가 명시적으로 선언 되어있음
}

public class CarExample{
  public static void main(String[] args) {
    Car myCar = new Car("아반떼", "검정색", "5000"); // String, String, int 를 호출하여 객체를 생성
    
    //Car myCar = new Car(); //기본 생성자를 호출 할 수 없다
  }
}
```

+ 필드 초기화
  + 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.
  + 다른 값으로 초기화를 하고싶다면 필드를 선언할 때 초기값을 주거나, 생성자에서 초기값을 줄 수 있다.
  + 생성자에서 필드 초기화
``` java
class Korean{  //Korea 클래스
  //필드
  String nation = "대한민국";
  String name;
  String ssn;
  
  //생성자
  Korean(String n, String s){
    name = n;
    ssn = s;
  }
}

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Korean k1 = new Korean("유승민", "990404-1111111");
		
		System.out.print(k1.name + k1.ssn);
	}

} //위 코드에서 출력값은 "유승민990404-1111111"이 나온다.
```
  + 위 코드에서는 생성자의 매개변수를 통해 name 필드와 ssn 필드를 초기화 한다. 
  + 관례적으로 필드와 매개 변수의 이름을 동일하게 한다.
  + 필드와 매개변수의 이름이 동일하면 생성자 내부에서 해당 필드에 접근할 수 없다.
  + 그래서 "this.필드"를 사용하여 객체 자신을 참조한다. 
``` java
public Korean(String name, String ssn){
  this.name = name;
  this.ssn = ssn;
```
  + 객체의 필드는 중요한 몇 개 필드만 매개변수를 통해 초기화되고 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화 한다.

+ 생성자 오버로딩
  + 생성자 오버로딩은 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.
``` java
public class Car {
  Car() {...}
  Car(String model) {...}
  Car(String model, String color) {...}
  Car(String model, String color, int maxSpeed) {...}
  
  Car(String color, String model) {...} // 위의   Car(String model, String color) {...}와 중복됨, 그러므로 오버로딩이 아님
}
```
  + 생성자가 오버로딩 되어있다면 new 연산자로 생성자를 호출할 때 매개값의 타입과 수에 의해 생성자가 결정된다.
  + 다양한 Car 객체 생성방법
``` java
Car car1 = new Car(); 
Car car2 = new Car("그랜저");
Car car3 = new Car("그랜저", "흰색");
Car car4 = new Car("그랜저", "흰색", 300);
```

+ 다른 생성자 호출(this())
   + 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다.
   + 이 경우에는 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 그 생성자를 호출하는 방법으로 개선할 수 있다.
``` java
Car(String model) {
   this(매개변수,  ...., 값...);
   실행문;
}
```
   + this()는 반드시 생성자의 첫줄에서만 허용된다.
   + this()의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 한다.
 

#### 메소드 
+ 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.
+ 필드를 읽고 수정하고 다른 객체를 생성하여 다양한 기능을 수행한다.
+ 객체 간의 데이터 전달의 수단으로 사용된다.

+ 메소드 선언
   + 메소드 선언은 선언부(리턴타입, 메소드이름, 매개변수선언)과 실행 블록으로 구성된다.
   + 리턴 타입은 메소드가 실행 후 리턴하는 값의 타입을 말한다.
   + 리턴값이 없는 메소드는 리턴 타입에 void가 와야하며 리턴값이 있을 경우엔 리턴값의 타입이 와야 한다.
``` java
void powerOn() { //리턴값이 없는 경우
....
}

double Caculation(int x, int y) { //리턴값이 있는경우
				  //매개변수 x, y도 같이 선언했음
....
}
```

   + 리턴값이 있는지 없는지에 따라 호출하는 방법도 다르다.
``` java
powerOn(); //리턴값이 없는 경우
double result = devide(10, 20); //리턴값이 있는 경우 매개변수에 값을 넣어줘야함
```
   + 위의 코드를 보면 리턴값이 없을 경우엔 저장할 변수가 필요하지 않다.
   + 리턴값이 있을경우에 리턴값과 같은 타입의 변수에 저장하지 않으면 컴파일 에러가 발생한다.
   + 메소드 이름은 관례적으로 소문자로 작성한다. 그 외에는 다른 이름 작성법과 같다.
   
+ 매개 변수 선언
   + 매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다.
   + 호출 시 매개값을 넣어주면 해당 위치의 매개 변수에 저장된다.

+ 매개 변수의 수를 모를경우
   - 몇 개의 변수가 입력될 지 모르겠다면 매개 변수를 배열 타입으로 선언한다.
   - 아래와 같이 값의 리스트만 넘겨주는 방법도 있다.
   - "···"로 선언된 매개 변수는 배열타입이므로 배열을 직접 매개값으로 사용하여도 된다.
``` java
int sum(int ··· values) { }
int result = sum(1,2,3);
int result2 = sum(1,2,3,4,5);
```
  

#### 리턴(return)문
```java
return 리턴값;
```
+ 리턴값이 있는 메소드
   + 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 위와 같이 리턴값을 지정해야 한다.
   + 리턴문의 리턴값은 리턴 타입이거나 리턴타입으로 변환될 수 있어야 한다.
   + 
