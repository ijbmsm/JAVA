# 클래스

## 객체 지향 프로그래밍
+ 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
  + 객체   : 자신의 속성(색깔, 나이, 동작, 모델명...등)을 가지고 있고 다른 것과 식별 가능한 것.
  + 필드   : 객체의 정보(상태)
  + 메소드 : 객체의 동작(기능)
``` java
class SmartPhone {
  /* 필드 */
  String name; // 이름
  String color; // 색상
  int price; // 가격
  
  /* 메소드 */
  void call(String phoneNum) {
    // 전화 걸기
  }
  void messege(String phoneNum) {
    // 메세지 보내기
  }
}
```

### 객체의 상호작용
+ 객체들은 각각 독립적으로 존재하며 객체들 사이의 상호작용 수단은 메소드이다.
  + 메소드 호출 : 객체가 다른 객체의 기능을 이용하는 것.
  + 매개값 : 메소드를 실행하기 위해 필요한 데이터. 
  + 리턴값 : 메소드가 실행하고 나서 호출한 곳으로 돌려주는 값.
```
int result = Calculator.add(10,20);
 리턴값 저장   객체      메소드
```

### 객체 간의 관계
+ 객체간의 관계에는 집합 관계, 사용 관계, 상속 관계가 있다.
  + 집합 관계 : 완성품과 부품의 관계
  + 사용 관계 : 객체가 다른 객체를 사용하는 관계
  + 상속 관계 : 상위객체를 기반으로 하위객체를 생성하는 관계
 
### 객체 지향 프로그래밍의 특징
+ 캡슐화 : 객체의 필드, 메소드를 하나로 묶어 구현 내용을 감추는 것.
  + 외부 객체는 객체가 노출해서 제공하는 필드와 메소드만 이용 가능.
  + 외부의 잘못된 사용(마음대로 변경)으로 인한 오남용을 막기 위함.

+ 상속 : 상위객체의 필드와 메소드를 하위 객체에게 물려줌
  + 하위 객체를 쉽게 빨리 설계할 수 있도록 도와준다.
  + 유지 보수가 편리하다.

+ 다형성 : 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질.
  + 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.
  + 객체는 부품화가 가능하다.

## 객체와 클래스
+ 메모리에서 사용하고 싶은 객체가 있다면 설계도로 해당 객체를 만들어야 한다. 자바에서는 설계도가 클래스이다. 
+ 클래스 : 객체를 생성하기 위한 설계도 혹은 틀. 객체들의 속성을 묶어 놓은 집합체
+ 객체 : 모든인스턴스를 대표하는 일반적 용어
+ 인스턴스 : 특정 클래스로부터 만들어진 객체(TV인스턴스, Car인스턴스)
+ 인스턴스화 : 클래스로부터 객체를 만드는 과정

+ 객체지향 프로그래밍 개발 단계
```
클래스 설계 -> 클래스를 가지고 객체 생성 -> 객체 프로그래밍
```

## 클래스 선언
+ 작성규칙

|번호|작성 규칙|예|
|:--|:------------|:-----|
|1|하나 이상의 문자로 이루어져야 한다.|Car, SportsCar|
|2|첫 번째 글자는 숫자가 올 수 없다.|2Car, 1999Sungmin|
|3|언더바, '$' 외의 특수 문자는 사용할 수 없다| $Car, @Car(X)|
|4|자바 키워드는 사용할 수 없다.|int, for|

+ 클래스 이름을 정했다면"클래스이름.java"로 소스 파일을 생성해야 한다. 
``` java
public class Car {

}

class Tire{
}
```
+ 하나의 자바 소스 파일에 작성된 클래스 중 하나의 클래스만 public으로 선언할 수 있다.
  + 소스파일 이름과 동일한 클래스에만 public으로 선언할 수 있다. 

## 객체 생성과 클래스 변수
+ new는 클래스로부터 객체를 생성시키는 연산자이다.
+ 생성자 : new 연산자를 통해 객체를 생성할 때 호출되는 멤버 변수(객체의 속성)을 초기화하는 역할
```
클래스 변수; 
변수 = new 클래스;

Car car; // Car 클래스의 객체를 참조하기 위한 참조변수(car)을 선언
car = new Car; // Car인스턴스를 생성한 후, 인스턴스의 주소를 car에 저장


클래스 변수 = new 클래스;
```
+ 위처럼 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다.
+ 객체의 사용
``` java
Car car = new Car;
car.speed = 100; //Car인스턴스의 멤버변수 speed의 값을 100으로 한다
car.speedUp(); //Car인스턴스의 메서드 speedUp()을 호출한다.
```

## 클래스의 구성 멤버
#### 필드
+ 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장한다.
+ 필드는 클래스에서 내부 멤버이기 때문에 멤버변수라고 불리고, 클래스 내 전역에서 사용하기 때문에 전역 변수라고 불린다.
+ 생성자와 메소드 밖에서 사용한다. 즉 클래스 안에서 독립적으로 선언되는 변수를 뜻한다.

+ 필드 선언
  + 필드는 클래스 블록 어디서든 존재할 수 있지만 생성자와 메소드 블록 내부에서는 선언될 수 없다.
  + 필드의 선언
``` java
String company = "현대자동차";
int speed = 300;
int age; // 선언만 하고 값을 넣지 않으면 초기값이 기본값으로 저장된다.
```
+ 필드의 사용
``` java
Car car = new Car;
car.speed = 100; //객체에 저장되어 있는 값(필드값)을 변경한다.
```
+ 필드를 사용한다는 것은 필드값을 읽고,변경하는 작업을 말한다.
+ 클래스 외부에서 사용할 경우 객체를 생성해야 한다.
  + 필드는 객체에 소속된 데이터이기 때문이다.
  + 필드의 사용은 변수와 비슷하지만 자신이 선언되지 않은 생성자, 메소드에서도 사용이 가능하다.

#### 생성자
+ 생성자는 객체 생성 시 초기화를 담당한다.
+ 메소드와 비슷하지만 메소드와는 다르게 리턴값이 없다.
+ new 연산자에 의해 생성자가 성공적으로 실행되면 heap영역에 객체가 생성되고 객체의 주소가 리턴된다.
+ 생성자가 실행되지 않고 에러가 발생한다면 객체는 생성되지 않는다.
+ 기본 생성자
  + 모든 클래스에는 생성자가 반드시 존재하고, 하나 이상 가질 수 있다..
  + 생성자 선언을 생략하면 컴파일러는 기본 생상자를 바이트 코드에 자동 추가시킨다.
``` java
ClassName() {} // 자동 추가된 생성자

public class Car{
  public Car() { } // 클래스가 public class로 선언되면 기보 생성자에서도 public이 붙는다.
}
```
  + 다음과 같이 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성시키면 컴파일러는 기본 생성자를 추가하지 않는다.
``` java
Car myCar = new Car();
```

+ 생성자 선언
``` java
클래스(매개변수 선언, ...){
  // 객체의 초기화 코드;
} 
``` 
  + 생성자는 리턴 타입이 없고, 클래스 이름과 동일하다. 
  + 매개 변수 선언은 생략할 수 있고, 여러 개를 선언할 수 있다.
``` java
public class Car {
  Car(String model, String color, int maxSpeed) {...} // 생성자가 명시적으로 선언 되어있음
}

public class CarExample{
  public static void main(String[] args) {
    Car myCar = new Car("아반떼", "검정색", "5000"); // String, String, int 를 호출하여 객체를 생성
    
    //Car myCar = new Car(); //기본 생성자를 호출 할 수 없다
  }
}
```

+ 필드 초기화
  + 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.
  + 다른 값으로 초기화를 하고싶다면 필드를 선언할 때 초기값을 주거나, 생성자에서 초기값을 줄 수 있다.
  + 생성자에서 필드 초기화
``` java
class Korean{  //Korea 클래스
  //필드
  String nation = "대한민국";
  String name;
  String ssn;
  
  //생성자
  Korean(String n, String s){
    name = n;
    ssn = s;
  }
}

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Korean k1 = new Korean("유승민", "990404-1111111");
		
		System.out.print(k1.name + k1.ssn);
	}

} //위 코드에서 출력값은 "유승민990404-1111111"이 나온다.
```
  + 위 코드에서는 생성자의 매개변수를 통해 name 필드와 ssn 필드를 초기화 한다. 
  + 관례적으로 필드와 매개 변수의 이름을 동일하게 한다.
  + 필드와 매개변수의 이름이 동일하면 생성자 내부에서 해당 필드에 접근할 수 없다.
  + 그래서 "this.필드"를 사용하여 객체 자신을 참조한다. 
``` java
public Korean(String name, String ssn){
  this.name = name;
  this.ssn = ssn;
```
  + 객체의 필드는 중요한 몇 개 필드만 매개변수를 통해 초기화되고 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화 한다.

+ 생성자 오버로딩
  + 생성자 오버로딩은 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.
``` java
public class Car {
  Car() {...}
  Car(String model) {...}
  Car(String model, String color) {...}
  Car(String model, String color, int maxSpeed) {...}
  
  Car(String color, String model) {...} // 위의   Car(String model, String color) {...}와 중복됨, 그러므로 오버로딩이 아님
}
```
  + 생성자가 오버로딩 되어있다면 new 연산자로 생성자를 호출할 때 매개값의 타입과 수에 의해 생성자가 결정된다.
  + 다양한 Car 객체 생성방법
``` java
Car car1 = new Car(); 
Car car2 = new Car("그랜저");
Car car3 = new Car("그랜저", "흰색");
Car car4 = new Car("그랜저", "흰색", 300);
```

+ 다른 생성자 호출(this())
   + 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다.
   + 이 경우에는 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 그 생성자를 호출하는 방법으로 개선할 수 있다.
``` java
Car(String model) {
   this(매개변수,  ...., 값...);
   실행문;
}
```
   + this()는 반드시 생성자의 첫줄에서만 허용된다.
   + this()의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 한다.
 

## 메소드 
+ 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.
+ 필드를 읽고 수정하고 다른 객체를 생성하여 다양한 기능을 수행한다.
+ 객체 간의 데이터 전달의 수단으로 사용된다.

+ 메소드 선언
   + 메소드 선언은 선언부(리턴타입, 메소드이름, 매개변수선언)과 실행 블록으로 구성된다.
   + 리턴 타입은 메소드가 실행 후 리턴하는 값의 타입을 말한다.
   + 리턴값이 없는 메소드는 리턴 타입에 void가 와야하며 리턴값이 있을 경우엔 리턴값의 타입이 와야 한다.
``` java
void powerOn() { //리턴값이 없는 경우
....
}

double Caculation(int x, int y) { //리턴값이 있는경우
				  //매개변수 x, y도 같이 선언했음
....
}
```

   + 리턴값이 있는지 없는지에 따라 호출하는 방법도 다르다.
``` java
powerOn(); //리턴값이 없는 경우
double result = devide(10, 20); //리턴값이 있는 경우 매개변수에 값을 넣어줘야함
```
   + 위의 코드를 보면 리턴값이 없을 경우엔 저장할 변수가 필요하지 않다.
   + 리턴값이 있을경우에 리턴값과 같은 타입의 변수에 저장하지 않으면 컴파일 에러가 발생한다.
   + 메소드 이름은 관례적으로 소문자로 작성한다. 그 외에는 다른 이름 작성법과 같다.
   
+ 매개 변수 선언
   + 매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다.
   + 호출 시 매개값을 넣어주면 해당 위치의 매개 변수에 저장된다.

+ 매개 변수의 수를 모를경우
   - 몇 개의 변수가 입력될 지 모르겠다면 매개 변수를 배열 타입으로 선언한다.
   - 아래와 같이 값의 리스트만 넘겨주는 방법도 있다.
   - "···"로 선언된 매개 변수는 배열타입이므로 배열을 직접 매개값으로 사용하여도 된다.
``` java
int sum(int ··· values) { }
int result = sum(1,2,3);
int result2 = sum(1,2,3,4,5);
```
  

#### 리턴(return)문
```java
return 리턴값;
```
+ 리턴값이 있는 메소드
   + 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 위와 같이 리턴값을 지정해야 한다.
   + 리턴문의 리턴값은 리턴 타입이거나 리턴타입으로 변환될 수 있어야 한다.
   + 리턴문 이후의 실행문은 실행되지 않는다(조건문에 따라 올 수도 있음)
```java
return;
```
+ 리턴값이 없는 메소드(void)
   + void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있다. 
   + 위와 같이 return문을 사용하면 메소드 실행을 강제 종료시킨다.
+ 메소드 호출
  + 클래스 내부에서 호출할 경우엔 단순한 메소드 이름으로 호출할 수 있지만 외부에서 호출할 경우에는 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용하여 메소드를 호출해야 한다.
  
+ 메소드 내부에서의 호출
``` java
void method1(String p1, int p2) {
}

void method2() {
   method1("홍길동", 100); //
}
```

+ 객체 외부에서 호출
   + 외부 클래스에서 메소드를 호출하기 위해서 클래스로부터 객체를 생성해야 한다.
   + 객체가 생성되었다면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드를 호출할 수 있다.
``` java
public class Car{
int speed; //필드

// 생성자(생략하면 기본생성자 선언됨)

int getSpeed() { 
 return speed;      //메소드
}

void keyTurnOn() {
 System.out.println("키를 돌립니다.");
}

void run() {
  for(int i = 10; i<=50; i+=10) {
    speed = i;
    System.out.println("달립니다.(시속:" + speed + " km/h)");
    }
  }
}

public class CarExample{
   public static void main(String[] args){
      Car myCar = new Car();    // 위의 Car클래스로부터 객체 생성
      myCar.keyTurnOn();        // "키를 돌립니다" 출력
      myCar.run();
      int speed = myCar.getSpeed() ;
      System.out.println("현재 속도 :" + speed + "km/h");
   }
}
```

#### 메소드 오버로딩 
``` java
int a = 10;
double b = 20.3;
plus(a, b);

double plus(double x, double y) {
   double result = x + y;
   return result;
```
+ 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩이라고 한다. 
+ 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서중 하나가 달라야 한다.
+ 메소드 오버로딩은 매개값을 다양하게 받아 처리할 수 있도록 사용한다.
+ 오버로딩된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다.
+ 위의 코딩처럼 매개변수의 타입이 다를 경우 JVM은 자동 타입 변환이 가능한지 확인하고 가능하다면 컴파일 오류가 나지 않고 정상적으로 작동한다.
+ 리턴타입만 다르면 오버로딩이 아니다.

## 인스턴스 멤버와 this
+ 인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말한다.
+ 인스턴스 필드와 인스턴스 메소드는 객체를 생성하고 참조 변수로 접근해야한다.
+ this는 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용한다.

## 정적 멤버와 static
+ 정적(static) 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.

#### 정적 멤버 선언
+ 정적 필드와 정적 메소드를 선언하는 방법은 선언시 static 키워드를 앞에 붙이면 된다.
``` java
public class 클래스 {
   static 타입 필드 = 초기값;
   
   static 리턴 타입 메소드(매개변수) {
   }
}
```
+ 정적 멤버는 클래스에 고정된 멤버이므로 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다.
+ 인스턴스 필드로 선언될 것인가, 정적 필드로 선언될 것인가의 판단은 객체의 데이터가 공용적으로 쓰이면 정적 필드로, 그렇지 않으면 인스턴스 필드로 선언하면 된다.
+ 메소드는 정적 인스턴스를 사용하면 정적 메소드, 인스턴스 메소드를 사용하면 인스턴스 메소드를 사용한다.

#### 정적 멤버 사용
``` java
클래스.필드;
클래스.메소드(매개값,...); // 매개변수가 아니다.
```
+ 정적 필드와 정적 메소드는 원칙적으로는 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근이 가능하다.
``` java
class Calculator{
   static double pi = 3.14159;
   static int plus(int x, int y){
   	int sum = x + y;
	return;
   }
}

public class CalculatorEx{
   public static void main(String[] args) {
   double result = 10 * 10 * Calculator.pi; //클래스 이름으로 접근
   
   Calculator ca = new Calculator; //객체 참조 변수로 접근
   int result2 = ca.plus(10, 20);
   }
}
```
+ 하지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다.
+ 정적 메소드와 정적 블록을 선언할 때 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 this 키워드도 사용이 불가능하다.
+ 만약 사용하고 싶다면 객체를 생성하고 참조 변수로 접근해야 한다.
#### 정적 초기화 블록
+ 정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이나 계산이 필요한 초기화 작업이 있을 수도 있기 때문에 자바에서는 정적 블록(static block)을 제공한다.
``` java
static{
  ....
}
```
+ 정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다.
+ 정적 블록은 클래스 내부에 여러개가 선언되어도 상관 없다.
+ 클래스가 메모리로 로딩될 때 선언된 순서대로 실행된다.

#### 싱글톤(Singleton)
+ 전체 프로그램에서 단 하나만 생성하도록 하는 객체를 싱글톤(Singleton)이라고 한다.
+ 싱글톤을 만들기 위해선 생성자를 외부에서 호출할 수 없도록 생성자 앞에 private 접근 제한자를 붙여준다.
+ 그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다.
```java
public class 클래스 {
   private static 클래스 singleton = new 클래스(); //정적 필드
   
   private 클래스() {} // 생성자
   
   static 클래스 getInstance() {
      return singleton;
   }
}
```
+ 외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출하는 방법이다.
+ getInstance() 메소드는 단 하나의 객체만 리턴한다.

## final 필드와 상수
#### final 필드
``` java
final 타입 필드 = 초기값;
```
+ final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다.
+ final 필드는 선언시에 초기값을 주거나, 생성자를 통한 초기값의 지정 외엔 값을 줄 방법이 없다.

#### 상수(static final)
+ 일반적으로 불편의 값을 상수라 부른다. (원주율, 지구의 무게, 날짜)
+ 이런 불변의 값을 저장하는 필드를 자바에서는 상수라고 한다.
+ final 필드와 상수는 비슷해보이지만 다른데 불변의 값(상수)는 객체마다 저장할 필요가 없는 공용성을 띄고 있고, 여러가지 값으로 초기화 될 수 없기 때문이다.
+ 상수는 static 이면서 final 이어야 한다.
+ 상수는 선언시에 초기값을 주는 것이 일반적이지만, 복잡한 초기화일 경우 정적 블록에서도 할 수 있다.
``` java
static final 타입 상수;
static {
   상수 = 초기값;
}
```
+ 상수이름은 전부 대문자로 작성하는 것이 관례이다. 다른 단어가 혼합되었다면 언더바로 단어들을 연결해준다.
``` java
static final double PI = 3.14159;
static final double EARTH_SURFACE_AREA;
```
## 패키지
+ 자바에서는 클래스를 체계적으로 관리하기 위해 패키지(package)를 사용한다.
+ 패키지의 물리적인 형태는 파일 시스템의 폴더이다.
+ 패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다.
+ 클래스의 전체 이름은 "패키지명+클래스명"인데 패키지가 상.하위로 구분되어 있다면 도트(.)를 사용해서 표현한다.
``` java
상위패키지.하위패키지.클래스
```
+ 패키지가 중요한 이유는 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스는 사용할 수 없기 때문이다. 클래스를 이동할 경우에는 패키지 전체를 이동시켜야 한다.

#### 패키지 선언
+ 패키지는 클래스를 컴파일하는 과정에서 자동적으로 생성되는 폴더이다.
``` java
package 상위패키지.하위패키지;

public class ClassName {...}
```
+ 패키지 작명법
   + 숫자로 시작해서는 안되고, 언더바, $, 를 제외한 특수 문자를 사용해서는 안된다.
   + java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안 된다.
   + 모두 소문자로 작성하는 것이 관례이다.

+ 패키지는 회사들 간의 패키지가 서로 중복되지 않도록 회사의 도메인 이름으로 작성한다.
```
com.samsung.projectname
com.hyundai.projectname
org.apache.projectname
```
#### 패키지 선언이 포함된 클래스 컴파일
+ 명령 프롬프트에서 컴파일 할 경우, 패키지 폴더가 자동으로 생성되려면 javac 명령어 다음에 -d 옵션을 추가하고 패키지가 생성될 경로를 지정해야 한다.
``` java
javac -d .		ClassName.java //현재 폴더 내에 생성
javac -d ..\bin		ClassName.java //현재 폴더와 같은 위치의 bin 폴더에 생성
javac -d C:\Temp\bin	ClassName.java //C:\Temp\bin 폴더에 생성
```
#### 이클립스에서 패키지 생성과 클래스 생성
+ 이클립스에서는 패키지만 따로 생성할 수 있고, 클래스를 생성할 때 동시에 생성시킬 수 있다.
+ 이클립스에서 패키지를 생성하려면 프로젝트의 src 폴더를 선택하고 메뉴에서 (File -> New -> Package)를 선택하면 된다. 또는 마우스 오른쪽 버튼을 클릭해서 (New -> Package)를 선택해도 좋다.
+ Name 입력란에 상위 패키지와 하위 패키지를 도트(.)로 구분해서 입력하고 (Finish) 버튼을 클릭하면 된다.
+ 클래스는 해당 패키지를 선택하고 메뉴에서 (File -> New -> Class)를 선택하여 생성한다. 또는 마우스 오른쪽 버튼을 클릭해서 (New -> Class)를 선택하여 생성한다.
+ 이클립스는 src에 있는 모든 내용을 컴파일해서 bin 폴더에 생성시킨다.
+ 이클립스는 패키지 선언이 없는 클래스는 default 패키지에 포함시킨다.

#### import문

+ 다른 패키지에 속하는 클래스를 사용하려면 두 가지 방법 중 하나를 선택해야 한다.
   + 패키지와 클래스를 모두 기술한다.
``` java
package com.mycompany;

public class Car{
   com.hankook.Tire  tire   = new com.hankook.Tire();
  (       타입     )(필드명)  (      객체생성         )
}
```
+ 위의 방법은 패키지 이름이 짧은 경우엔 불편함이 없지만 패키지 이름이 길거나 사용해야 할 클래스 수가 많으면 코드가 난잡해 보인다.
+ 그래서 두 번째 방법인 import 문을 주로 사용한다.

``` java
package com.mycompany;

import com.hankook.Tire;
(또는 import com.hankook.*;)

public class Car {
   Tire tire = new Tire();
}
```
+ import문이 작성되는 위치는 패키지 선언과 클래스 선언 사이다.
+ 패키지에 포함된 다수의 클래스를 사용해야 한다면 클래스별로 import문을 작성할 필요 없이 *를 사용해서 import문을 한번에 작성하면 된다.
+ 하지만 하위 패키지의 경우 import문을 하나 더 작성해야 한다.
``` java
import com.mycompany.*;
import com.mycompany.project.*;
```
+ 이클립스에는 import문을 직접 작성하지 않고 사용된 클래스를 조사해서 필요한 import문을 자동적으로 추가하는 기능이 있다.
```
Ctrl + Shift + O
```

## 접근 제한자
+ main() 메소드를 가지지 않는 대부분의 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스이다.
+ 라이브러리 클래스를 설계할 때 외부 클래스에서 접근하게 만들지 접근하지 못하게 만들지 설계해야한다.
+ 자바는 이러한 기능을 구현하기 위해 접근 제한자(Access Modifier)를 제공하고 있다. 
+ 
|접근 제한|적용대상|접근할 수 없는 클래스|
|------|-------------|--------------------|
|public|클래스,필드,생성자, 메소드| 없음|
|protected|필드, 생성자, 메소드|자식 클래스가 아닌 다른 패키지에 소속된 클래스|
|default|클래스,필드,생성자,메소드|다른 패키지에 소속된 클래스|
|private|필드,생성자,메소드|모든 외부 클래스|

#### 클래스의 접근 제한
+ 클래스에 적용할 수 있는 접근 제한은 public과 default 단 두가지이다.
```
class 클래스 {...} //default접근 제한

public class 클래스 {...} // public 접근 제한
```
+ 클래스를 선언할 때 public을 생략했다면 클래스는 default 접근 제한을 가진다. 
+ default 클래스는 다른 패키지에서는 사용할 수 없다.
+ public 접근제한은 다른 패키지에서도 아무 제한 없이 사용할 수 있다.
+ 인터넷으로 배포되는 라이브러리 클래스들은 모두 public 접근 제한을 가지고 있다.

#### 생성자의 접근 제한
``` java
public class ClassName{
   public ClassName(...) {..}
   
   protected ClassName(...) {..}
   
   ClassName(...) {..}
   
   private ClassName(...) {..}
}
```
+ 자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다. 

|접근 제한자|생성자|설명|
|------|--------|----------------------|
|public|클래스()|클래스가 default 접근 제한을 가진다면 클래스 사용이 같은 패키지로 한정되므로, 비록 생성자가 public 접근 제한을 가지더라도 같은 패키지에서만 생성자를 호출할 수 있다.|
|protected|클래스()|default와는 같지만 다른 패키지에 속한 클래스가 해당 클래스의 자식(child) 클래스라면 생성자를 호출할 수 있다.|
|default|클래스()|생성자를 선언할 때 제한자를 생략했다면 default 접근 제한을 가진다. 다른 패키지에서는 생성자를 호출할 수 없도록 한다.|
|private|클래스()|클래스 내부에서만 생성자를 호출할 수 있고, 객체를 만들 수 있다.|


#### 필드와 메소드의 접근 제한
+ 메소드와 필드에서도 생성자의 접근 제한과 비슷하다.
``` java
public|protected|private| static 타입 필드;
public|protected|private| static 리턴 타입 메소드(...) {...}
```
|접근 제한자|생성자|설명|
|------|--------|----------------------|
|public|필드 메소드(...)|필드와 메소드가 public 접근 제한을 가질 경우 클래스도 public 접근 제한을 가져야 한다. 클래스가 default 접근 제한을 가지게 되면 같은 패키지 안에서만 클래스가 사용되기 때문|
|protected|필드 메소드(...)|다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 필드와 메소드를 사용할 수 있다|
|default|필드 메소드(...)|다른 패키지에서는 필드와 메소드를 사용할 수 없다|
|private|필드 메소드(...)|오로지 클래스 내부에서만 사용할 수 있다|

## Getter와 Setter 메소드
+ 일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.
+ 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.
+ 이러한 역할을 하는 메소드가 Setter이다.
``` java
void setSpeed(double speed) {
   if(speed < 0) {
      this.speed = 0;
      return;
   } 
   else {
      this.speed = speed;
   }
}
```
+ 객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우 메소드로 필드값을 가공한 후 외부로 전달하는데 이럴 때 사용하는 메소드가 바로 Getter이다.
``` java
double getSpeed() {
   double km = speed * 1.6; //필드값인 마일을 km 단위로 환산 후 외부로 리턴
   return km;
}
```
+ 클래스를 선언할 때 가능하다면 필드를 private로 선언해서 외부로부터 보호하고, Setter와 Getter 메소드를 작성해 필드값을 안전하게 변경/사용하는 것이 좋다.
+ 필드 타입이 boolean일 경우 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다.

## 어노테이션
+ 어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다.
```
@AnnotationName
```
+ 어노테이션은 세가지 용도로 사용된다
   + 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
   + 코드 문법 에러는 대표적으로 @Override를 사용한다. 메소드 선언 시 사용되는데 메소드가 오버라이드(재정의) 된 것임을 알려주어 정확히 오버라이드 되지 않았으면 에러를 발생시킨다.
   + 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
   + 실행 시 특정 기능을 실행하도록 정보를 제공

#### 어노테이션 타입 정의와 적용
+ 어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사하다.
``` java
public @interface AnnotationName{
}
```
+ 이렇게 정의한 어노테이션은 코드에서 다음과 같이 사용한다.
```
@AnnotationName
```
+ 어노테이션은 엘리먼트(element)를 멤버로 가질 수 있다.
```
public @interface AnnotationName {
   타입 elementName default 값;
   String elmentName1();
   int elementName2() default 5;
}
```
+ 엘리먼트의 타입으로는 int나 double과 같은 기본 데이터 타입이나 String, 열거 타입, Class 타입, 이들의 배열 타입을 사용할 수 있다.
+ 이렇게 정의한 어노테이션을 코드에서 적용할 때에는 다음과 같이 기술한다.
``` java
@AnnotationName(elementName1 = "값", element2 = 3); //디폴트 값을 주지 않았기 때문에 값을 기술함
```

#### 어노테이션 적용 대상

|ElementType 열거 상수|적용 대상|
|------|-------------|
|Type|클래스, 인터페이스, 열거 타입|
|ANNOTATION_TYPE|어노테이션|
|FIELD|필드|
|CONSTRUCTOR|생성자|
|METHOD|메소드|
|LOCAL_VARIABLE|로컬 변수|
|PACKAGE|패키지|

+ 어노테이션이 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다.
+ @Target의 기본 엘리먼트인 value는 ElementType 배열을 값으로 가진다.

#### 어노테이션 유지 정책
+ 어노테이션 정의 시 한 가지 더 추가해야 할 내용은 사용 용도에 따라 @AnnotationName을 어느범위까지 유지할 것인지 지정해야 한다.

|RetentionPolicy 열거 상수|설명|
|-----|-------------------------------------|
|SOURCE|소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다.|
|CLASS|바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.|
|RUNTIME|바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다.|

+ 리플렉션(Reflection)이란 런타임 시에 클래스의 메타 정보를 얻는 기능을 말한다.
+ 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻으려면 어노테이션 유지 정책을 RUNTIME으로 설정해야 한다.
+ 어노테이션 유지정책을 지정할 때에는 @Retention 어노테이션을 사용한다.

``` java
@Target({ElementType.Type, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationName{
}
```

#### 런타임 시 어노테이션 정보 사용하기
+ 어노테이션 자체는 아무런 동작을 가지지 않는 단지 표식일 뿐이지만, 리플렉션을 이용해서 어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있다.
+ 클래스에 적용된 어노테이션 정보를 얻으려면 java.lang.Class를 이용하면 되지만, 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class의 메소드를 통해 java.lang.reflect 패키지의 Field, Constructor, Method 타입의 배열을 얻어야 한다.
+ 그 다음 Class, Field, Constructor, Method가 가지고 있는 메소드를 호출해서 적용된 어노테이션 정보를 얻을 수 있다.
